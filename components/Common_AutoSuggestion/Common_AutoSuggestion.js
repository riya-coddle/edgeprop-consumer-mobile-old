import React, { Component } from 'react';
import {
  View,
  Text,
  ScrollView,
  Dimensions,
  TouchableOpacity,
  Alert,
  Image
} from 'react-native';
import Common_IconMenu from '../Common_IconMenu/Common_IconMenu';
import Loading from '../../components/Common_Loading/Common_Loading'

const screenWidth = Dimensions.get('window').width;
//Suggestion Search
const PROXY_URL = "?";
const API_DOMAIN = "https://www.edgeprop.my/jwdsonic/api/v1/global/suggest?ptype=rl&query=";
//https://www.edgeprop.my/jwdsonic/api/v1/global/suggest?query=d&ptype=rl

const LIMIT_DISTRICTS = 4;
const LIMIT_HDB_TOWNS = 4;
const LIMIT_NEW_LAUNCHES = 2;
const LIMIT_AMENITIES = 2;
const LIMIT_PROJECTS = 12;
const LIMIT_PLACES = 4;
const AUTO_SUGGESTION_GROUPS = {
    //auto
    suggestion:{
        name: 'Suggestion',
        url: "key={KEYWORD}&st={STATE}",
        proxy: { url: PROXY_URL, encode: false },
        limit: 15,
        displayKey: "n",
        optionsInfo: {
          icon: 'https://dkc9trqgco1sw.cloudfront.net/images/icons/web4/Districts.png',
          name: "District",
        }
    }
}

const AUTO_SUGGESTION_ICONS = {
    p:{
        i: {
          icon: "https://dkc9trqgco1sw.cloudfront.net/images/icons/web4/Industrial.png",
        },
        l: {
          icon: "https://dkc9trqgco1sw.cloudfront.net/images/icons/web4/Landed.png",
        },
        r: {
          icon: "https://dkc9trqgco1sw.cloudfront.net/images/icons/web4/ico_penthouse.png",
        },
        c: {
          icon: "https://dkc9trqgco1sw.cloudfront.net/images/icons/web4/ShopHouse.png",
        },
        common:{
            icon: "https://dkc9trqgco1sw.cloudfront.net/images/icons/web4/HDB.png",
        }
    },
    j:{
        icon: 'https://dkc9trqgco1sw.cloudfront.net/images/icons/web4/New+Launches.png'
    },
    a:{
        icon: 'https://dkc9trqgco1sw.cloudfront.net/images/icons/web4/Districts.png'
    },
    g:{
        icon: 'https://dkc9trqgco1sw.cloudfront.net/images/icons/web4/Places.png'
    }
}

 export default class Common_AutoSuggestion extends Component {
  groups = {};
  searchText = ''; // searched text
  options = {};
  caching = true;
  keyword = ''; // keyword for internal use (generated by `searchText` value)
  cachedSuggestions = {}; // will be used if props.caching = true
  cachedStaticData = {}; // will be used if there are static file as the data source
  fetchCounterPerGroup = [];
  fetchTimeout = setTimeout(() => {
    //initial fetch
  }, 0);
  handlerResultTimeOut = setTimeout(() => {
    //initial result handler
  }, 0);
  constructor(props) {
    super(props);
    this.data = [];
    //this.result = [];
    //this.tempResult = [];
    this.state = {
      text: ''
    };
    this.rightArrow = require('../../assets/icons/Right-arrow.png');
    this.categoryIcon = '';
    this.groups = AUTO_SUGGESTION_GROUPS
  }
  _initItem() {
    //console.log('Common_AutoSuggestion 223 _initItem',this.props.data);
    if (this.props.data != undefined && this.props.data != this.data) {
      this.data = this.props.data;
    }
  }

  //SUGGESTION FEATURES
  getAllSuggestions(value, keyword, state) {
    if(!state)
        state = 'Kuala Lumpur';

    this.result = [];
    this.tempResult = [];
    this.fetchCounterPerGroup = [];
    Object.keys(this.groups).map(key => {
      this.getSuggestionsData(key, value, keyword, state)
    })

    return this.result;
  }
  generateKeyword(value) {
    return value.toLowerCase();
  }

  getSuggestions(group, keyword, data) {
    // convert json object to array
    /*if (data instanceof Array === false) {
      data = Object.values(data);
  }*/
    // apply the limit
    // if(this.groups[group].limit && data.length > parseInt(this.groups[group].limit)) {
    if (this.groups[group].limit) {
      var limitedData = [];
        if(data.p){
            data.p.forEach((d, i) => {
                limitedData.push({...d,t:'p',name:d.n});
            });
        }
        if(data.j){
            data.j.forEach((d, i) => {
                limitedData.push({t:'j',name:d});
            });
        }
        if(data.a){
            data.a.forEach((d, i) => {
                limitedData.push({...d,t:'a',name:d.area});
            });
        }
        if(data.g){
            data.g.forEach((d, i) => {
                limitedData.push({...d,t:'g',name:d.name});
            });
        }

      data = limitedData;

      var handlerData = data.map(value => {
        return value.t;
      });
      //console.log('handlerData',handlerData);
      var handlerTempResult = this.tempResult.map(value => {
        return value.t;
      });

      if (!handlerTempResult.includes(...handlerData)) {
        this.tempResult = [...this.tempResult, ...data];
      }

      //   this.tempResult = [...this.tempResult, ...data];
      clearTimeout(this.handlerResultTimeOut);
      this.handlerResultTimeOut = setTimeout(() => {
        this.result = this.tempResult;
        //console.log('Common_AutoSuggestion 291 this.result',this.result);
        this.props.onGetResult(this.result)
      }, 500);
      this.result = this.tempResult;
      this.props.onGetResult(this.result)
    }

    // ---------
    // IMPORTANT: if the keyword has been changed when response is received, just cache it
    // ---------
    if (keyword == this.keyword) {
      this.afterGetSuggestions(group, keyword, data, true);
    } else {
      this.cacheSuggestions(group, keyword, data);
    }
  }
  searchFromStaticData(data, toSearch, key, sortFunc, limit, removeDuplicates) {
    key = key || 'n';
    limit = limit || 100000; // if limit has not given, just consider this big number
    removeDuplicates = removeDuplicates || false;
    var results = [];
    var re = new RegExp('^' + toSearch, 'i');
    var foundSuggestions = [];

    // searching from the begining
    for (var i = 0; i < data.length; i++) {
      if (data[i][key].match(re) && results.indexOf(data[i]) === -1) {
        results.push(data[i]);
      }
    }
    // searching from beginning of any word
    if (results.length < limit) {
      re = new RegExp('\\b' + toSearch, 'i');
      for (var i = 0; i < data.length; i++) {
        if (data[i][key].match(re) && results.indexOf(data[i]) === -1) {
          results.push(data[i]);
        }
      }
    }
    // searching for any position
    if (results.length < limit) {
      re = new RegExp(toSearch, 'i');
      for (var i = 0; i < data.length; i++) {
        if (data[i][key].match(re) && results.indexOf(data[i]) === -1) {
          results.push(data[i]);
        }
      }
    }

    // sort the results as per the given function
    if (typeof sortFunc === 'function') {
      results.sort(sortFunc);
    }

    // removing the duplicates
    var results2 = results;
    results = [];
    for (var i = 0; i < results2.length; i++) {
      if (
        (removeDuplicates &&
          !foundSuggestions.indexOf(results2[i][key].toLowerCase()) > -1) ||
        !removeDuplicates
      ) {
        results.push(results2[i]); // adding the non-duplicate suggestion to the final output
        foundSuggestions.push(results2[i][key].toLowerCase()); // collecting the suggestions
      }
    }
    results2 = [];
    return results;
  }
  getSuggestionsData(group, value, keyword, state) {

    if (
      this.cachedSuggestions[group] &&
      this.cachedSuggestions[group][keyword]
    ) {
      this.afterGetSuggestions(
        group,
        keyword,
        this.cachedSuggestions[group][keyword],
        false
      );
    } else if (this.groups[group].static && this.cachedStaticData[group]) {
      var data = this.cachedStaticData[group];
      data = this.searchFromStaticData(
        data,
        value,
        this.groups[group].displayKey,
        this.groups[group].sort,
        this.groups[group].limit,
        this.groups[group].removeDuplicates
      );
      this.getSuggestions(group, keyword, data);
    }
    data = [];
    if (!this.fetchCounterPerGroup.includes(group)) {
      this.fetchCounterPerGroup.push(group);
      //console.log('this.groups[group].url',this.groups[group].url);
      var url = this.groups[group].url.replace(
        '{KEYWORD}',
        encodeURIComponent(value)
      );

      url = url.replace(
        '{STATE}',
        encodeURIComponent(state)
      );
      //   console.log("URL",url)
      if (
        this.groups[group].proxy &&
        this.groups[group].proxy.url &&
        this.groups[group].proxy.url.length > 0
      ) {
        if (this.groups[group].proxy.encode) {
          url = encodeURIComponent(url);
        }
        url = API_DOMAIN + keyword;
        //console.log("URL", url)
      }
      //console.log('Common_AutoSuggestion 409 suggestion',url);
      // fetching data
      fetch(url)
        .then(function (response) {
          return response.json();
        })
        .then(
          function (data) {
            // if the data coming through static files
            if (this.groups[group].static) {
              this.cachedStaticData[group] = data;
              data = this.searchFromStaticData(
                data,
                value,
                this.groups[group].displayKey,
                this.groups[group].sort,
                this.groups[group].limit,
                this.groups[group].removeDuplicates
              );
            } else if (data.results) {
              data = data.results;
            } else if (this.groups[group].for == 'article_tags') {
              var tags = [];
              if (Object.keys(data) && Object.keys(data).length) {
                Object.keys(data).map(d => {
                  tags.push({
                    name: d
                  });
                });
              }
              data = tags;
            }
            //console.log('data',data)
            this.getSuggestions(group, keyword, data)
          }.bind(this)
        )
        .catch(function (ex) {
          console.log('parsing failed', ex);
        });
    }
  }
  cacheSuggestions(group, keyword, data) {
    if (this.caching) {
      this.cachedSuggestions[group] = this.cachedSuggestions[group] || {};
      this.cachedSuggestions[group][keyword] =
        this.cachedSuggestions[group][keyword] || {};
      this.cachedSuggestions[group][keyword] = data;
    }
  }
  isNoSuggestions() {
    var noSuggestions = true;
    Object.keys(this.groups).map(key => {
      if (this.options[key] && this.options[key].length > 0) {
        noSuggestions = false;
      }
    });

    return noSuggestions;
  }

  clearAllSuggestions() {
    // clear the options
    Object.keys(this.groups).map(key => {
      if (this.options[key]) {
        this.options[key] = [];
      }
    });

  }
  afterGetSuggestions(group, keyword, data, storeInCache) {
    // caching the suggestions
    if (storeInCache && this.caching) {
      this.cacheSuggestions(group, keyword, data);
    }
    this.options[group] = data;
    let newState = {
      options: Object.assign({}, this.options),
      hint: !this.isClicked && this.searchText.length > 1 ? this.getHint() : ''
    };
    if (
      !this.isClicked &&
      this.state.popup != 'show' &&
      !this.isNoSuggestions()
    ) {
      newState = {
        ...newState,
        ...{
          popup: 'show'
        }
      };
    } else if (this.state.popup == 'show' && this.isNoSuggestions()) {
      newState = {
        ...newState,
        ...{
          popup: 'hide'
        }
      };
    }
    this.setState(newState);
  }
  getHint() {
    var hint = '';
    var re = new RegExp('^' + this.searchText, 'i');
    var displayKey = '';

    Object.keys(this.props.groups).map(group => {
      displayKey = this.groups[group].displayKey;
      if (this.options[group]) {
        // searching from the begining
        for (var i = 0; i < this.options[group].length; i++) {
          if (this.options[group][i][displayKey].match(re)) {
            if (hint.length == 0) {
              hint =
                this.searchText +
                this.options[group][i][displayKey].substring(
                  this.searchText.length
                );
            }
          }
        }
      }
    });
    if (hint.length > 0) {
      hint = hint.replace('&#039;', "'");
    }
    return hint;
  }

  _isShow(category) {
    // DISTRICTS
    //console.log('Common_AutoSuggestion 540 category',category);
    //console.log('Common_AutoSuggestion 541 this.props.',this.props);
    if (category == 'Districts' && (this.props.district != undefined)) {
      return this.props.district
    }
    // HDB_TOWNS
    if (category == 'HDB Towns' && (this.props.hdbtowns != undefined)) {
      return this.props.hdbtowns
    }
    // NEW_LAUNCHES
    if (category == 'New Launches' && (this.props.newlaunches != undefined)) {
      return this.props.newlaunches
    }
    // AMENITIES
    if (category == 'Amenities' && (this.props.amenities != undefined)) {
      return this.props.amenities
    }
    // PROJECTS
    if (['LRTs', 'Schools', 'MRTs', 'Shopping Malls'].includes(category) && (this.props.projects != undefined)) {
      return this.props.projects
    }
    // PLACES
    if (category == 'place' && (this.props.place != undefined)) {
      return this.props.place
    }
    return true
  }

  render() {
    this._initItem();
    let projects = [];
    let street = [];
    let area = [];
    let empty = [];
    let totalItems = []
    let totalItemsFlag = false

    if(this.data.length > 0) {
      this.data.map((item,i) => {
          empty = []
          if(item.t == 'p') {
            projects.push(item);
          } else if(item.t == 'a') {
            area.push(item)
          } else if (item.t == 'j') {
            street.push(item.name)
          } else if(item.t == 'empty') {
            empty.push(item)
          }      
      });
      empty.push({name: this.props.keyword})
      totalItems.push(projects,area,street)
      if( totalItems ) {
        totalItemsFlag = true
      }
    } 

    if(this.props.isEmpty) {
      totalItemsFlag = true
      empty.push({name: this.props.keyword})
      projects = []
      area = [] 
      street = [] 
    }


    var getCategoryName = category => {
      if (category == 'p') return 'Project';
      if (category == 'j') return 'Street';
      if (category == 'a') return 'District';
      if (category == 'g') return 'Travel Time';
      else {
        return category;
      }
    };

    var getIcon = (data, category) => {
      //console.log('category',category);
      var getCategoryIcon = Object.values(data);
      if (category.t == 'p'){
          if (['i', 'l', 'r', 'c'].includes(category.ty)){
              return data.p[category.ty].icon;
          }else{
              return data.p.common.icon;
          }
      }
      if (['j', 'a', 'g'].includes(category.t))
        return data[category.t].icon;

    };
    
    var getIconItem = (title) => {
      if(title == 'PROJECTS') {
        return require('../../assets/icons/projects.png');
      } else if( title == 'STREET') {
        return require('../../assets/icons/land.png');
      } else {
        return require('../../assets/icons/district_new.png');
      }
    }

    var _renderText = (text, keyword) => {
      var tempChar = '';
      var item = '';
      if(typeof text === 'object' && text.constructor === Object) {
        item = text.name;
      } else {
        item = text
      }
      return (
        <Text
            allowFontScaling={false}
            style={{
              padding: 10,
              fontSize: 16,
              fontFamily: 'Poppins-Medium',
              color: '#414141',
              alignItems: 'flex-start'
            }}
          >
            {item}
          </Text>  
      );
     // var arrChar = text.split('');
      /*return arrChar.map((char, index) => {
        tempChar = '';
        if (keyword.toLowerCase().includes(char.toLowerCase())) {
          tempChar = keyword.toLowerCase();
        }
        return (
          <Text
            allowFontScaling={false}
            key={index}
            style={{
              fontSize: 15,
              fontFamily:
                keyword.toLowerCase() == tempChar
                  ? 'Poppins-Bold'
                  : 'Poppins-Regular'
            }}
          >
            {char}
          </Text>
        );
      });*/
    };

    var renderItems = (data,title) => {
      if(data.length > 0) {
        return (
          <View>
          {this.props.isEmpty ? 
            (
               <TouchableOpacity onPress={() => this.props.onItemPress({name:this.props.keyword}, 1)} style={{ marginBottom : -20, padding: 10,  alignItems: 'center' }}>
                <Text
                    allowFontScaling={false}
                    style={{ textAlign: 'left', width: '100%',fontSize: 14, fontFamily:'Poppins-Medium', color: '#488BF8', marginBottom: 10 }}
                    ellipsizeMode={'tail'}
                    numberOfLines={1}>
                   Keyword "{this.props.keyword}"
                  </Text>
               </TouchableOpacity> 
            ):
            (
                <View>
                  <View>
                  <Text allowFontScaling={false} style={{ backgroundColor: '#ececec', paddingVertical: 10, paddingHorizontal: 22, textAlign: 'left', width: '100%',fontSize: 14, fontFamily:'Poppins-Medium', color: '#909090' }}>{title}</Text>
                  </View>
                {data.map((value,index)=> {
                return (
                  <TouchableOpacity
                  style={{ display: this._isShow(value.t) ? 'flex' : 'none' }}
                  key={index}
                  onPress={() => this.props.onItemPress(value, index)}
                    >
                    <View style={{ paddingVertical: 10, paddingHorizontal: 22, display: 'flex', flexDirection: 'row', justifyContent:'space-between', alignItems: 'center', borderBottomWidth: 1, borderColor: '#ececec'}}>
                      {title == '' && (
                          <Text
                            allowFontScaling={false}
                            style={{ textAlign: 'left',fontFamily: 'Poppins-Medium', fontSize: 15, alignItems: 'center', width: '100%', color: '#488BF8' }}
                            ellipsizeMode={'tail'}
                            numberOfLines={1}>
                          Keyword "{value.name}"
                          </Text>
                      )}
                      <View>
                        {title != '' && (
                          <Image
                            style={{width: 30, height: 30, marginRight: 20}}
                            source={getIconItem(title)}
                          />
                        )}                      
                      </View>
                      <View style={{ alignItems: 'flex-start', flex: 1 }}>
                        {title != '' && (
                          <Text
                            allowFontScaling={false}
                            style={{ textAlign: 'left', width: '75%', color: value.t == 'MRTs' ? Object.values(AUTO_SUGGESTION_GROUPS)[3].optionsInfo.MRTs.color[value.s] : '#4a4a4a' }}
                            ellipsizeMode={'tail'}
                            numberOfLines={1}
                          >
                          {_renderText(value.name, this.props.keyword)}
                         </Text>
                        )}
                        {title == 'PROJECTS' && (
                          <Text 
                            allowFontScaling={false}
                            style={{ 
                            marginTop: -20,
                            fontFamily: 'Poppins-Regular', 
                            fontSize: 12, 
                            color:'#414141'  }}>
                            {'\n'+value.area} , {value.state}
                            </Text>
                        )}
                    </View>
                    <View>
                      <Text allowFontScaling={false}></Text>
                    </View>
                    <View style={{ paddingBottom: 0 }} />
                  </View>    
                  </TouchableOpacity>
              );
            })

          }
              </View>
            )}
          </View>  

        ) 
      }
    }

    var renderItem = this.data.map((value, index) => (
      value.t!= 'New Launches'? //Temporary Hide New Launches Category
      <TouchableOpacity
        style={{ display: this._isShow(value.t) ? 'flex' : 'none' }}
        key={index}
        onPress={() => this.props.onItemPress(value, index)}
      >
          <Text allowFontScaling={false}>
            Keyword "{this.props.keyword}"
          </Text>
          <View style={{ flexDirection: 'row', paddingVertical: 10 }}>
             <Image
                style={{width: 30, height: 30, marginLeft: 10, marginRight: 10}}
                source={{uri: getIcon(AUTO_SUGGESTION_ICONS, value) }}
              />
            <Text
              allowFontScaling={false}
              style={{ paddingTop: 10, width: '44%', color: value.t == 'MRTs' ? Object.values(AUTO_SUGGESTION_GROUPS)[3].optionsInfo.MRTs.color[value.s] : '#4a4a4a' }}
              ellipsizeMode={'tail'}
              numberOfLines={1}
            >
              {_renderText(value.name, this.props.keyword)}
            </Text>
            <Text
              allowFontScaling={false}
              style={[{
                fontFamily: 'Poppins-Regular',
                fontSize: 13,
                color: '#4a4a4a',
                fontWeight: '400',
                width: '25%',
                paddingLeft: 40,
              },
              this.props.textCategoryStyle]}>
              {getCategoryName(value.t)}
            </Text>
            <View style={{ paddingRight: 15, paddingLeft: 10, justifyContent: 'center' }}>
            </View>
          </View>
      </TouchableOpacity>:<View><Text allowFontScaling={false}>No Items Found!</Text></View>
    ));

    if(totalItemsFlag) {
      return (
          <ScrollView style={{ 
            marginTop: (this.props.isEmpty) ? -10 : -42,
            marginRight: -10,
            marginLeft: -10
          }}>
          {!this.props.hasText && (
            <Loading />
          )}        
          {renderItems(empty,'')}
          {renderItems(area,'DISTRICTS')}
          {renderItems(projects,'PROJECTS')}
          {renderItems(street,'STREET')}
          <View style={{ padding: 0 }}/>
          </ScrollView>
      );
    } else {
      return <View />;
    }
  }
}
