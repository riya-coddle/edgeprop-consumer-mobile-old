import React, { Component } from 'react';
import {
  Platform,
  StyleSheet,
  TextInput,
  Text,
  View,
  Image,
  TouchableHighlight,
  Alert,
  TouchableOpacity,
  Dimensions,
  AsyncStorage
} from 'react-native';
import Common_IconMenu from '../../components/Common_IconMenu/Common_IconMenu.js';
import Common_AutoSuggestion from '../../components/Common_AutoSuggestion/Common_AutoSuggestion';
import { HeaderBackButton } from 'react-navigation';
import CustomSelect from '../../components/Common_CustomSelect/CustomSelect.js';
import NavigationHelper from '../../components/Common_NavigationHelper/Common_NavigationHelper.js'
import styles from './HeaderSearchStyle'
import { Divider } from 'react-native-elements';
import IconMenu from '../Common_IconMenu/Common_IconMenu'
import BookmarkHelper from '../../components/Common_BookmarkHelper/Common_BookmarkHelper.js'

var iconStar = require('../../assets/icons/star.png');
var equalizer = require('../../assets/icons/equalizer.png');
var icon = require('../../assets/icons/search-icon.png');
var clearIcon = require('../../assets/icons/Close-white.png');
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;

const dropDown = [
    { label: 'Buy' , value: 'Buy' },
    { label: 'Rent' , value: 'Rent' }
];

class Common_HeaderSearch extends Component {
  groups = {};
  searchText = ''; // searched text
  options = {};
  caching = true;
  keyword = ''; // keyword for internal use (generated by `searchText` value)
  cachedSuggestions = {}; // will be used if props.caching = true
  cachedStaticData = {}; // will be used if there are static file as the data source
  fetchCounterPerGroup = [];
  fetchTimeout = setTimeout(() => {
    //initial fetch
  }, 0);
  handlerResultTimeOut = setTimeout(() => {
    //initial result handler
  }, 0);
  constructor(props) {
    super(props);
    this.result = [];
    this.tempResult = [];
    this.state = {
      text: props.defaultText || '',
      options: Object.assign({}, this.options),
      state: props.defaultState || 'Kuala Lumpur',
      dropDownDefault:  dropDown[0].value,
      hasText : false,
      userInfo: {}
    };

    this._onPress = this._onPress.bind(this);
    this._onChangeText = this._onChangeText.bind(this);
    this._onClear = this._onClear.bind(this);
    this._onSubmitEditing = this._onSubmitEditing.bind(this);
    this.addFilter = this.addFilter.bind(this);
    this.saveSearch = this.saveSearch.bind(this);
    this.dropDownChange = this.dropDownChange.bind(this);
    this.resetUsrInfo = this.resetUsrInfo.bind(this);
    // Object.keys(this.props.groups).map((key) => {
    //     this.options[key] = [];
    //   });

    this.style = {
      // default value
      // component
      hintText: '',
      fontSize: 15,
      lineHeight: 25,
      hintColor: '#909090',
      inputColor: '#909090',
      backgroundColor: '#FFF',
      width: '100%',
      height: 45,
      margin: 2,
      padding: 5,
      borderRadius: 0,
      borderWidth: 0,
      borderColor: '#466482',
      iconMargin: 5,
      iconWidth: 25,
      iconHeight: 25,
      editable: true,
      fontFamily: 'Poppins-Light',
      alignItems: 'center',
      marginLeft: 7,
      paddingRight: 3,
      autoFocus: false
    };
  }
  _initItem() {
    if (this.props.groups != undefined && this.props.groups != this.groups) {
      this.groups = this.props.groups;
    }
    if (this.props.defaultState != undefined && this.props.defaultState != this.state.state) {
        this.state = {
          state: this.props.defaultState || 'Kuala Lumpur',
        };
    }

  }
  _initStyle() {
    //init icon
    if (this.props.icon && this.props.icon != this.icon) {
      this.icon = this.props.icon;
    }
    //init clearIcon
    if (this.props.clearIcon && this.props.clearIcon != this.clearIcon) {
      this.clearIcon = this.props.clearIcon;
    }
    // init fontSize
    if (this.props.fontSize && this.props.fontSize != this.style.fontSize) {
      this.style.fontSize = this.props.fontSize;
    }
    // init hintColor
    if (this.props.hintColor && this.props.hintColor != this.style.hintColor) {
      this.style.hintColor = this.props.hintColor;
    }
    // init hintText
    if (this.props.hintText && this.props.hintText != this.style.hintText) {
      this.style.hintText = this.props.hintText;
    }
    // init inputColor
    if (
      this.props.inputColor &&
      this.props.inputColor != this.style.inputColor
    ) {
      this.style.inputColor = this.props.inputColor;
    }
    // init backgroundColor
    if (
      this.props.backgroundColor &&
      this.props.backgroundColor != this.style.backgroundColor
    ) {
      this.style.backgroundColor = this.props.backgroundColor;
    }
    // init width
    if (this.props.width && this.props.width != this.style.width) {
      this.style.width = this.props.width;
    }
    // init height
    if (this.props.height && this.props.height != this.style.height) {
      this.style.height = this.props.height;
    }
    // init margin
    if (this.props.margin && this.props.margin != this.style.margin) {
      this.style.margin = this.props.margin;
    }
    // init padding
    if (this.props.padding && this.props.padding != this.style.padding) {
      this.style.padding = this.props.padding;
    }
    // init borderRadius
    if (
      this.props.borderRadius &&
      this.props.borderRadius != this.style.borderRadius
    ) {
      this.style.borderRadius = this.props.borderRadius;
    }
    // init borderWidth
    if (
      this.props.borderWidth &&
      this.props.borderWidth != this.style.borderWidth
    ) {
      this.style.borderWidth = this.props.borderWidth;
    }
    // init borderColor
    if (
      this.props.borderColor &&
      this.props.borderColor != this.style.borderColor
    ) {
      this.style.borderColor = this.props.borderColor;
    }
    // init iconMargin
    if (
      this.props.iconMargin &&
      this.props.iconMargin != this.style.iconMargin
    ) {
      this.style.iconMargin = this.props.iconMargin;
    }
    // init iconWidth
    if (this.props.iconWidth && this.props.iconWidth != this.style.iconWidth) {
      this.style.iconWidth = this.props.iconWidth;
    }
    // init iconHeight
    if (
      this.props.iconHeight &&
      this.props.iconHeight != this.style.iconHeight
    ) {
      this.style.iconHeight = this.props.iconHeight;
    }
    // init editable
    if (this.props.editable && this.props.editable != this.style.editable) {
      this.style.editable = this.props.editable;
    }
    // init fontFamily
    if (
      this.props.fontFamily &&
      this.props.fontFamily != this.style.fontFamily
    ) {
      this.style.fontFamily = this.props.fontFamily;
    }
    // init alignItems
    if (
      this.props.alignItems &&
      this.props.alignItems != this.style.alignItems
    ) {
      this.style.alignItems = this.props.alignItems;
    }
    // init marginLeft
    if (
      this.props.marginLeft &&
      this.props.marginLeft != this.style.marginLeft
    ) {
      this.style.marginLeft = this.props.marginLeft;
    }
    // init paddingRight
    if (
      this.props.paddingRight &&
      this.props.paddingRight != this.style.paddingRight
    ) {
      this.style.paddingRight = this.props.paddingRight;
    }
    //init autoFocus
    if (this.props.autoFocus && this.props.autoFocus != this.style.autoFocus) {
      this.style.autoFocus = this.props.autoFocus;
    }
  }

  componentWillReceiveProps(nextProps, nextState) {
    //console.log('nextProps',nextProps);
    //console.log('next text',nextProps.defaultText);
    this.setState({
      text: nextProps.defaultText
    });
  }

  addFilter() {
    if(this.props.onIconPress){
      this.props.onIconPress()
    }
  }

  async componentDidMount() {
      const auth = await AsyncStorage.getItem("authUser");
      if(auth && auth != '') {
        let authItems = JSON.parse(auth);
      //  console.log(authItems)
        if(authItems.status == 1) {
          this.setState({ userInfo: authItems })
        }  
      }
  }

  async resetUsrInfo() {
        const user = await AsyncStorage.getItem("authUser");  
        if(user && user != '') {
            let authItems = JSON.parse(user);
            if(authItems.status == 1) {

                this.setState({ userInfo: authItems })
            }
        }   
  }

  async saveSearch() {
    await this.resetUsrInfo();
    if(this.state.userInfo.uid != 0) {
      if(this.props.onSavedSeachPress){
        this.props.onSavedSeachPress()
      }
    } else {
      if(this.refs.bookmarkHelper != undefined){
            this.refs.bookmarkHelper._checkLogin(
                ()=>{
                    this.state.isLogin = true;
                    if(this.state.isLogin){
                        this.refs.menu._toggleMenu()
                        this.setState({
                          isBookmark: this.state.isBookmark ? false : true
                        })
                    this.refs.bookmarkHelper._updateBookmark(this.props.nid, this.state.isBookmark, this._checkBookmark)
                    }
                },
                ()=>{
                    // console.log('ian 12345');
                    // this.refs.bookmarkHelper._updateBookmark(this.props.nid, !this.state.isBookmark, this._checkBookmark)
                    this.refs.navigationHelper._navigate('SignUpLanding', {
                      data: {},
                      _handleBack: this._handleBack,
                      _handleClose: this._handleClose
                    })
                }
            )
            // if(this.state.isLogin){
            //     this.refs.menu._toggleMenu()
            //     this.setState({
            //       isBookmark: this.state.isBookmark ? false : true
            //     })
            //     if(this.refs.bookmarkHelper != undefined){
            //         this.refs.bookmarkHelper._updateBookmark(this.props.nid, !this.state.isBookmark, this._checkBookmark)
            //     }
            // }
        }
    }
    
  }

  dropDownChange(val){
    this.setState({ dropDownDefault: val })
    console.log('val',val);
    if(this.props.onDropdownToggle){
      this.props.onDropdownToggle(val);
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    if (
      nextProps.hintText != this.hintText ||
      nextProps.editable != this.editable
    ) {
      return true;
    }
    return JSON.stringify(nextState) != JSON.stringify(this.state);
  }

  getText() {
    return this.state.text;
  }

  setText(text) {
    this.setState({ text: text });
  }
  clearText() {
    this._onClear();
  }

  _onSubmitEditing() {
    if (this.props.onSubmitEditing) {
      this.props.onSubmitEditing(this.state.text);
    }
  }

  _onPress() {
    if (this.props.onPress) {
      this.props.onPress();
    }
  }

  _onChangeText(stext) {
    //console.log('hghgh jhjhjhj', this.props);
    let hasText = false;
    let text = stext.replace(/[\u2018\u2019]/g, "'") // --> to handle apostrophes character on ios
    this.setState({
        text: text
    });
    this.keyword = this.refs.suggestion.generateKeyword(text);
    //console.log('Common_HeaderSearch 261 props',this.props.navigation);
    if (this.props.onChangeText) {
      clearTimeout(this.fetchTimeout);
      this.fetchTimeout = setTimeout(() => {
       // console.log('Common_HeaderSearch 265 state',this.state.text)
        if (this.state.text.length > 0) {
          //console.log('text', this.state.text)
          hasText = true
          //console.log('Common_HeaderSearch 267 text',this.state.text)
          this.refs.suggestion.getAllSuggestions(
            this.state.text,
            this.refs.suggestion.generateKeyword(this.state.text),
            this.state.state
        );
        }
      }, 800);
      if (this.state.text && this.state.text.length <= 0) {
        this.refs.suggestion.clearAllSuggestions();
        this.result = [];
        //console.log('Common_HeaderSearch 277 after clearing');
      }
      //console.log('Common_HeaderSearch 279 befor onChangeText',this.result);
     // console.log('hasText', hasText);
      this.props.onChangeText(text, this.result, hasText);
    }
  }

  _onClear() {
    if (this.props.onClear) {
      this.props.onClear();
      this.result = [];
    }
    this.setState({
      text: '',
      state: 'Kuala Lumpur'
    });
  }
  render() {
    this._initStyle(); 
    this._initItem();
    if (this.props.editable == false) {
      return (
        <View>
          <TouchableOpacity onPress={this._onPress}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: this.style.alignItems,
                padding: this.style.padding,
                backgroundColor: this.style.backgroundColor,
                width: this.style.width,
                height: this.style.height,
                borderColor: this.style.borderColor,
                borderRadius: this.style.borderRadius
              }}
            >
              <Image
                style={{
                  width: this.style.iconWidth,
                  height: this.style.iconHeight,
                  margin: this.style.iconMargin,
                  marginLeft: 10
                }}
                source={icon}
              />
              <Text
                allowFontScaling={false}
                style={[
                  {
                    flex: 1,
                    fontSize: this.style.fontSize,
                    fontFamily: this.style.fontFamily,
                    lineHeight: this.style.lineHeight,
                    color: this.style.hintColor,
                    marginLeft: this.style.marginLeft,
                    marginTop: 5
                  }
                ]}
                ellipsizeMode={'head'}
                numberOfLines={2}
              >
                {screenWidth < 400 ? 
                  (screenWidth <= 370 && this.style.hintText.length > 20 ? 
                      this.style.hintText.substring(0, 20) + " ..." :
                      (screenWidth <= 330 && this.style.hintText.length > 20 ? 
                        this.style.hintText.substring(0, 20) + " ...":this.style.hintText)): this.style.hintText}
              </Text>
            </View>
          </TouchableOpacity>
        </View>
      );
    } else {
      return (
        <View style={[this.props.isHomePage?styles.homepageSearchContainer:(this.props.isDetails?styles.detailsSearch:styles.headerSearch)]} >
        <NavigationHelper
          ref={"navigationHelper"}
          navigation={this.props.navigation}
        />
        <BookmarkHelper
          ref={"bookmarkHelper"}
          navigation = {this.props.navigation}
        />
        <View
          style={{
            display: 'flex',
            flexDirection: 'row',
            alignItems: this.style.alignItems,
            padding: this.style.padding,
            backgroundColor: this.style.backgroundColor,
            width: this.style.width,
            height: this.style.height,
            borderColor: 'red',
            borderRadius: 2,
            shadowColor: '#e4e1e1',
            shadowOffset: { width: 0, height: 4 },
            shadowOpacity: 1,
            shadowRadius: 10,
            elevation: 4,
            alignItems: 'center',
            zIndex: 0,
            justifyContent: 'center',
            //shadowRadius: 3,
            //elevation: 2,
          }}
        >
        {this.props.isHomePage && (
          <View style={{ width: '20%' }}>
            <CustomSelect
            label={''}
            value={this.state.dropDownDefault}
            valueExtractor={(item) => item.value}
            labelExtractor={(item) => item.label}
            data={dropDown}
            onChangeText={ (val) => this.dropDownChange(val) }
          />
           </View>
        )}
        <View style={[this.props.isHomePage?styles.iconContainer:styles.inputContainer]}>        
          <Common_AutoSuggestion
            ref={'suggestion'}
            onGetResult={value => {
              this.props.onChangeText(this.state.text, value, true);
            }}
          />
          <TouchableOpacity onPress={this._onPress}>
          <View  style={{ display: 'flex', flexDirection: 'row' }}> 
          {this.props.showIconSearch ? (
            <Image
              style={{
                width: 20.5,
                height: 20.5,
                marginTop: 14.5,
                marginLeft: 10
              }}
              source={icon}
            />
          ) : (
            <Text allowFontScaling={false}>{''}</Text>
          )}
            <TextInput
              allowFontScaling={false}
              autoFocus = {this.style.autoFocus}
              underlineColorAndroid="transparent"
              autoCorrect={false}
              placeholder={screenWidth < 400 ? 
                        (screenWidth == 320 && this.style.hintText.length > 20 ? 
                        this.style.hintText.substring(0, 16) + " ..." :
                        (screenWidth == 360 && this.style.hintText.length > 20 ? 
                        this.style.hintText.substring(0, 25) + " ...":this.style.hintText)): this.style.hintText}
              placeholderTextColor={this.style.hintColor}
              style={{
                flex: 1,
                textAlignVertical: 'center',
                color: this.style.inputColor,
                borderColor: this.style.borderColor,
                height: this.style.height,
                fontSize: this.style.fontSize,
                fontFamily: 'Poppins-Regular',
                lineHeight: 15,
                marginLeft: this.style.marginLeft,
                marginTop: 5,
                zIndex: 0

              }}
              onChangeText={this._onChangeText}
              onSubmitEditing={this._onSubmitEditing}
              value={this.state.text}
              editable={this.props.needsEdit}
            />
          {this.props.isProperty &&  (
            <View style={{ display: 'flex', flexDirection: 'row', alignItems: 'center', marginTop: -8 }}>
            <TouchableOpacity onPress={()=>this.saveSearch()}>
            <IconMenu
              type={'icon-text'}
              imageSource={iconStar}
              imageHeight={19}
              imageWidth={19}
              isPropertyList={true} 
            />
            </TouchableOpacity >
            <TouchableOpacity onPress={()=>this.addFilter()}>
              <IconMenu
                type={'icon-text'}
                imageSource={equalizer}
                imageHeight={19}
                imageWidth={19}
                isPropertyList={true} 
              />
            </TouchableOpacity >
          </View>
          
          )}
          {this.state.text && this.state.text.length > 0 ? (
            <Common_IconMenu
              imageSource={clearIcon}
              type={'icon'}
              imageHeight={18}
              imageWidth={18}
              onPress={this._onClear}
             />
          ) : (
            <View />
          )}
          </View>
          </TouchableOpacity>   
        </View>
        </View>
        </View>
      );
    }
  }
}

export default Common_HeaderSearch;
